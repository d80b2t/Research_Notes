\documentclass[11pt]{article}
%\setlength {\textwidth}{180mm} 
%\setlength {\textheight}{260mm}
%\topmargin=-35.00mm
%\oddsidemargin=-10.00mm
%\pagestyle{empty}


\input{format}

\begin{document}

\title{Introduction to Data Science in Python}
\author{Nicholas P. Ross}
\date{\today}
\maketitle


\begin{abstract}
Here are my (NPR's) notes on the ``Introduction to Data Science in Python''
Coursera course from the University of Michigan that I'm taking in
November 2016.  The URL for that course is\\
\href{https://www.coursera.org/learn/python-data-analysis/home/welcome}{{\tt
https://www.coursera.org/learn/python-data-analysis/home/welcome}}.
The URL for these notes is:\\
\href{https://github.com/d80b2t/Research_Notes/tree/master/Python}{\tt
https://github.com/d80b2t/Research\_Notes/tree/master/Python}
\end{abstract}


\tableofcontents


\newpage
\section{Week 1: Python Fudamentals}

\subsection{Introduction to Specialization}
Kinda a preamble!\\
General Course Outline (4 modules) \\
1. General Python Basics \\
2. The {\it pandas} Toolkit \\
3. Advanced Querying and Manipulation in {\it pandas}\\
4. Basic Statistical Analysis with {\it numpy} and {\it scipy}, and project.\\

\subsection{Syllabus}
\href{https://www.coursera.org/learn/python-data-analysis/supplement/68grE/syllabus}{\tt https://www.coursera.org/learn/python-data-analysis/supplement/68grE/syllabus}. 

If you're having problems, here are a couple of great places to go for help:
\begin{itemize}
\item{1. If the problem is with the Coursera platform such as
verification on assignments, in video quiz problems, or the Jupyter
Notebooks, please check out the Coursera Learner Support Forums.}
\item{2. If the problem deals with understanding the assignment or how
to use the Jupyter Notebooks, please read our Jupyter Notebook FAQ
page in the course resources.}
\item{3. If you have questions with the content of the course, or
questions about programming in python or with the toolkits described,
you can contact your peers and the course instructors in the
discussion forums, or go to Stack Overflow.}
\end{itemize}

\subsection{Data Science}
\href{http://drewconway.com/zia/2013/3/26/the-data-science-venn-diagram}{\tt http://drewconway.com/zia/2013/3/26/the-data-science-venn-diagram}

\begin{figure}[p]
    \includegraphics[width=0.8\textwidth]{Data_Science_VD.png} 
 \caption{Drew Conway's Venn Diagram.}
    \label{fig:DS_Venn}
\end{figure}

David Donoho, Professor of Statistics in Stanford., ``50 Years of Data Science''. 
1. Data Exploration and Preparation.\\
2. Data Representation and Transformation. \\
3. Computing with Data. \\
4. Data Modeling.\\
5. Data Visualization and Presentation. \\
6. Science about Data Science. \\



\subsection{The Coursera Jupyter Notebook System}
All pretty standard, straighforward. 


\subsection{Python Functions}
Of course, Python has traditional software structures like
functions. Here's an example, refactoring that previous code into a
function. You'll see the def statement indicates that we're writing a
function. Then each line that is part of the function needs to be
indented with a tab character or a couple of spaces.

\begin{lstlisting}
def add_numbers(x, y):
    return x + y

add_numbers(1, 2)
\end{lstlisting}

Okay, functions are great but they're a bit different than you might
find in other languages and here are some of subtleties
involved. First, since there's no typing, you don't have to set your
return type. Second, you don't have to use a return statement at all
actually. There's a special value called None that's returned. None is
similar to null in Java and represents the absence of value.  Third,
in Python, you can have default values for parameters.
Here's an example.
\begin{lstlisting}
def add_numbers(x,y,z=None):
    if (z==None):
        return x+y
    else:
        return x+y+z

print(add_numbers(1, 2))
print(add_numbers(1, 2, 3))
\end{lstlisting}
 In this example, we can rewrite the add numbers function to take
three parameters, but we could set the last parameter to be None by
default. This means that you can call add numbers with just two values
or with three, and you don't have to rewrite the function signature to
overload it.

\begin{lstlisting}
def do_math(a, b, kind='add'):
  if (kind=='add'):
    return a+b
  else:
    return a-b

do_math(1, 2)
\end{lstlisting}


    \subsection{Python Types and Sequences}
    The absence of static typing in Python doesn't mean that there
    aren't types. The Python language has a built in function called type
    which will show you what type of given reference is. Some of the
    common types includes strings, the type is discussed. Integers and
    floating point variables. As we've seen you can have reference as to
    function as well as a function type also exist.
    
    Typed objects have properties associated with them, and these
    properties can be data or functions. A lot of Python's built around
    different kinds of sequences or collection types. And there's three
    native kinds of collections that we're going to talk about, {\it
      tuples}, {\it lists}, and {\it dictionaries}.
    
        \subsubsection{Tuples}
        {\it A tuple is a sequence of variables which itself is immutable.}
        That means that a tuple has items in an ordering, but that it cannot
        be changed once created. We write tuples using parentheses, and we can
        mix types for the contents for the tuples. Here's a tuple which has
        four items. Two are numbers, and two are strings.
        \begin{lstlisting}
          x = (1, 'a', 2, 'b')
          type(x)
        \end{lstlisting}
        
        \subsubsection{Lists}
        Lists are very similar, but they can be mutable, so you can
        change their length, number of elements, and the element values. A
        list is declared using the square brackets.
        \begin{lstlisting}
          x = [1, 'a', 2, 'b']
          type(x)
        \end{lstlisting}
        There are a couple of different ways to change the contents of a
        list. One is through the append function which allows you to append
        new items to the end of the list.  
        \begin{lstlisting}
          x.append(3.3)
          print(x)
          \end{lstlisting}
          
        Both lists in tuple are iterable
        types, so you can write loops to go through every value they hold. The
        norm, if you want to look each item in the list is to use a {\tt for} 
        statement. This is similar to the for each loop in languages like Java
        and C\# but note that there's no typing required.
        \begin{lstlisting}
          for item in x:
          print(item)
        \end{lstlisting}

        List and tuples can also be accessed as arrays might in other
        languages, by using the square brackets operator, which is called the
        indexing operator. The first item of the list starts at position zero
        and to get the length of the list, we use the built in lan
        function. There are some other common functions that you might expect
        like min and max which will find the minimum or maximum values in a
        given list or tuple.
        \begin{lstlisting}
          i=0
          while( i != len(x) ):
              print(x[i])
              i = i + 1
          \end{lstlisting}

        \subsubsection{Other, really useful, {\tt string} stuff}
        \begin{lstlisting}
           firstname = 'Christopher'
           lastname = 'Brooks'
           print(firstname + ' ' + lastname)
           print(firstname*3)
           print('Chris' in firstname)
        \end{lstlisting}
        {\tt split} returns a list of all the words in a string, or a list split on a specific character.
        \begin{lstlisting}
          firstname = 'Christopher Arthur Hansen Brooks'.split(' ')[0] # [0] selects the first element of the list
          lastname = 'Christopher Arthur Hansen Brooks'.split(' ')[-1] # [-1] selects the last element of the list
          print(firstname)
          print(lastname)
          \end{lstlisting}


        \subsubsection{Dictionaries}
        Dictionaries are similar to lists and tuples in that they hold
        a collection of items, but they're labeled collections which do not
        have an ordering. This means that for each value you insert into the
        dictionary, you must also give a key to get that value out. In other
        languages the structure is often called a map. And in Python we use
        curly braces to denote a dictionary. Here is an example where we might
        link names to email addresses. You can see that we indicate each item
        of the dictionary when creating it using a pair of values separated by
        colons. That you can retrieve a value for a given label using the
        indexing operator.
        \begin{lstlisting}
          x = {'Christopher Brooks': 'brooksch@umich.edu', 'Bill Gates': 'billg@microsoft.com'}
          x['Christopher Brooks'] # Retrieve a value by using the indexing operator

          x['Kevyn Collins-Thompson'] = None
          x['Kevyn Collins-Thompson']

          ## Iterate over all of the keys:
          for name in x:
               print(x[name])

          brooksch@umich.edu
          None
          billg@microsoft.com

          ## Iterate over all of the values:
          for email in x.values():
              print(email)
          
         ## Iterate over all of the items in the list:

         ## You can unpack a sequence into different variables:
         x = ('Christopher', 'Brooks', 'brooksch@umich.edu')
         fname, lname, email = x
        \end{lstlisting}
        This last example is a little bit different, and it's an
        example of something called unpacking. In Python you can have
        sequence, that's a list or a tuple of values, and you can unpack those
        items into different variables through assignment in one statement.

    \subsection{Python More on Strings}
    In Python 3 strings are Unicode based, which led to the 256
    characters in ASCII.  But the world doesn't just run on Latin
    characters and there's a need to support non-English languages as well
    as characters which are not commonly used in words, but are commonly
    used elsewhere like mathematical operators. The Unicode Transformation
    Format, or UTF, is an attempt to solve this. It can be used to
    represent over a million different characters. This includes not only
    human languages like you might expect, but symbols like emojis
    too. Python 3 uses Unicode by default so there is no problem in
    dealing with international character sets.
    \begin{lstlisting}
      sales_record = {
        'price': 3.24,
        'num_items': 4,
        'person': 'Chris'}
      
      sales_statement = '{} bought {} item(s) at a price of {} each for a total of {}'
      
      print(sales_statement.format(sales_record['person'],
                                    sales_record['num_items'],
                                    sales_record['price'],
                                    sales_record['num_items']*sales_record['price']))
    \end{lstlisting}

      
\newpage
    \subsection{Python Demonstration: Reading and Writing CSV files}
    \begin{lstlisting}
      import csv
      % precision 2
      with open('mpg.csv') as csvfile:
          mpg = list(csv.DictReader(csvfile))
          
       mpg[:3] # The first three dictionaries in our list.
    \end{lstlisting}
    {\tt csv.Dictreader} has read in each row of our csv file as a
    dictionary. {\tt len} shows that our list is comprised of 234
    dictionaries.
    {\tt keys} gives us the column names of our csv:
    \begin{lstlisting}
      mpg[0].keys()
    \end{lstlisting}
    This is how to find the average cty fuel economy across all cars. All values in the dictionaries are strings, so we need to convert to float.
    \begin{lstlisting}
      sum(float(d['cty']) for d in mpg) / len(mpg)
      ## Wondering if `d' here is some universal shorthand for the dict...??
    \end{lstlisting}

    \noindent
    Here's a more complex example where we are grouping the cars by
    number of cylinder, and finding the average cty mpg for each group.
    \begin{lstlisting}
      cylinders = set(d['cyl'] for d in mpg)
      cylinders
      
      CtyMpgByCyl = []
      
      for c in cylinders: # iterate over all the cylinder levels
          summpg = 0
          cyltypecount = 0
          for d in mpg: # iterate over all dictionaries
              if d['cyl'] == c: # if the cylinder level type matches,
                  summpg += float(d['cty']) # add the cty mpg
                  cyltypecount += 1 # increment the count

          CtyMpgByCyl.append((c, summpg / cyltypecount)) # append the tuple ('cylinder', 'avg mpg')

      CtyMpgByCyl.sort(key=lambda x: x[0])
      CtyMpgByCyl
     \end{lstlisting}

    \subsection{Python Dates and Times}
     \begin{lstlisting}
       import datetime as dt
       import time as tm

       # time returns the current time in seconds since the Epoch. (January 1st, 1970)
       tm.time()
       
       # Convert the timestamp to datetime.
       dtnow = dt.datetime.fromtimestamp(tm.time())
       dtnow

       # get year, month, day, etc.from a datetime
       dtnow.year, dtnow.month, dtnow.day, dtnow.hour, dtnow.minute, dtnow.second 

       # create a timedelta of 100 days
       delta = dt.timedelta(days = 100)  
       delta

       today = dt.date.today()
       
       today - delta # the date 100 days ago

       datetime.date(2016, 8, 7)

       today > today-delta # compare dates
     \end{lstlisting}


    
    \subsection{Advanced Python Objects map()}
    
    \subsection{Advanced Python Lambda and List Comprehensions}
    
    \subsection{Advanced Python Demonstration: The Numerical Python Library (Numpy)}
    
    



\section{Week Two}

\section{Week Three}

\section{Week Four}



















\section{References and Bibliography}




\bibliographystyle{mn2e}
\bibliography{/cos_pc19a_npr/LaTeX/tester_mnras}

\end{document}

